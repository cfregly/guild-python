Project
=======

>>> import guild.project

Loading projects
----------------

Projects can be loaded from a file:

>>> p_from_file = guild.project.from_file(sample("guild.yml"))
>>> p_from_file.source
'.../samples/guild.yml'
>>> p_from_file.dir
'.../samples'

They can also be loaded from a directory, provided the project name is
'guild.yml':

>>> p_from_dir = guild.project.from_dir(samples_dir())
>>> p_from_dir.source
'.../samples/guild.yml'
>>> p_from_file.dir
'.../samples'

An Error is raised if the project file doesn't exist (note there are
differences between Python2 and Python3 so we just check the error
message here).

>>> try:
...     guild.project.from_file("does_not_exist")
... except Exception as e:
...     print(str(e))
[Errno 2] No such file or directory: 'does_not_exist'

We'll use the project reference `project` for the remaining tests.

>>> project = p_from_file

Project attributes
------------------

Project level attributes may be read using the `attr` method:

>>> project.attr("name")
'MNIST'
>>> project.attr("description")
'Guild MNIST example'
>>> project.attr("sources")
['*.py']
>>> project.attr("undefined") is None
True

Sections
--------

Project sections are grouped under section headings. You can return a
list of sections for a given heading using the `sections` method:

>>> [section.path for section in project.sections("models")]
[['models', 'expert'], ['models', 'intro']]

You can retrieve a section using `section`:

>>> section = project.section("models", "intro")
>>> section.path
['models', 'intro']

When a section key isn't available (e.g. the user doesn't specify it)
you can find a default section using `default_section`:

>>> section = project.default_section("models")
>>> section.path
['models', 'intro']
>>> section.attr("default")
True

Flags
-----

The `flags` method can be used as a convenience function for
`attrs("flags", {})`:

>>> pprint(project.flags())
{'batch_size': 100, 'datadir': './data', 'epochs': 10, 'rundir': '$RUNDIR'}

Similarly, section flags may be read using `flags`:

>>> pprint(project.section("models", "expert").flags())
{'batch_size': 200, 'epochs': 20}

All flags
---------

Flags may be explicitly defined in flag sections, but they can also be
extended using command line arguments, either in the form of separate
flags (key value pairs) or as profiles, which represent sets of flags.

To return all flags associated with a project or section, use the
`all_flags` methods on the applicable object.

To illustrate, we'll define a list of command line profiles:

>>> project.command_line_profiles = ["quick-train"]

and use `all_flags` to resolve these along with the flags defined in
the project:

>>> pprint(sorted(project.all_flags()))
[('batch_size', 100),
 ('datadir', './data'),
 ('epochs', 5),
 ('rundir', '$RUNDIR')]

A "long-train" profile yields this:

>>> project.command_line_profiles = ["long-train"]
>>> pprint(sorted(project.all_flags()))
[('batch_size', 100),
 ('datadir', './data'),
 ('epochs', 50),
 ('rundir', '$RUNDIR')]

We can further specify command line flags, which add or redefine both
profile and project level flags:

>>> project.command_line_flags = [("epochs", "11"), ("bar", "456")]
>>> pprint(sorted(project.all_flags()))
[('bar', '456'),
 ('batch_size', 100),
 ('datadir', './data'),
 ('epochs', '11'),
 ('rundir', '$RUNDIR')]

We can do the same for sections, which may contain their own flag
definitions. First we'll reset our command line state:

>>> project.command_line_profiles = []
>>> project.command_line_flags = []

The expert section redefined the epochs used:

>>> section = project.section("models", "expert")
>>> pprint(sorted(section.all_flags()))
[('batch_size', 200),
 ('datadir', './data'),
 ('epochs', 20),
 ('rundir', '$RUNDIR')]

We can now further refine the flags using profiles:

>>> project.command_line_profiles = ["long-train"]
>>> pprint(sorted(section.all_flags()))
[('batch_size', 200),
 ('datadir', './data'),
 ('epochs', 50),
 ('rundir', '$RUNDIR')]

and then again using command line flags:

>>> project.command_line_flags = [("epochs", "12")]
>>> pprint(sorted(section.all_flags()))
[('batch_size', 200),
 ('datadir', './data'),
 ('epochs', '12'),
 ('rundir', '$RUNDIR')]

Generating a project
--------------------

Projects can be create directly with data:

>>> data = {
...     "models": {
...         "intro": {
...             "train": "intro"
...         }
...     }
... }
>>> project = guild.project.Project(data)

In this case, the project's source and dir are None:

>>> print(project.source)
None
>>> print(project.dir)
None

In cases where a project is operated on (e.g. train, evaluate, etc.)
it should have at least a directory. It's also helpful to annotate
generated files to note how they were created:

>>> project = guild.project.Project(
...    data,
...    dir=".",
...    annotation="generated by test")
>>> project.dir
'.'
>>> project.annotation
'generated by test'

Edge case: implicit default section
-----------------------------------

A section is considered 'default' if it's the only section.

>>> data = {
...     "models": {
...         "intro": {
...             "train": "intro"
...         }
...     }
... }
>>> project = guild.project.Project(data)
>>> section = project.default_section("models")
>>> section.path
['models', 'intro']

Note that the section is not explicitly marked as default:

>>> print(section.attr("default"))
None
